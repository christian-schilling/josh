<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Just One Single History</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="usecases.html"><strong aria-hidden="true">2.</strong> Use cases</a></li><li class="chapter-item expanded "><a href="filters.html"><strong aria-hidden="true">3.</strong> Filter syntax</a></li><li class="chapter-item expanded "><a href="cli.html"><strong aria-hidden="true">4.</strong> Command Line usage</a></li><li class="chapter-item expanded "><a href="proxy.html"><strong aria-hidden="true">5.</strong> Proxy</a></li><li class="chapter-item expanded "><a href="workspace.html"><strong aria-hidden="true">6.</strong> Workspaces</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Just One Single History</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="just-one-single-history"><a class="header" href="#just-one-single-history">Just One Single History</a></h1>
<p>Josh combines the advantages of monorepos with those of multirepos by leveraging a blazingly-fast,
incremental, and reversible implementation of git history filtering.</p>
<p>This documentation describes the filtering mechanism, as well as
the tools provided by Josh: the josh library, <code>josh-proxy</code> and <code>josh-filter</code>.</p>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<p>Traditionally, history filtering has been viewed as an expensive operation that should only be
performed to fix issues with a repository, such as purging big binary files or removing
accidentally-committed secrets, or as part of a migration to a different repository structure, like
switching from multirepo to monorepo (or vice versa).</p>
<p>The implementation shipped with git (<code>git-filter branch</code>) is only usable as a once-in-a-lifetime
last resort for anything but tiny repositories.</p>
<p>Faster versions of history filtering have been implemented, such as
<a href="https://github.com/newren/git-filter-repo">git-filter-repo</a> or the
<a href="https://rtyley.github.io/bfg-repo-cleaner/">BFG repo cleaner</a>. Those, while much faster, are
designed for doing occasional, destructive maintenance tasks, usually with the idea already in mind
that once the filtering is complete the old history should be discarded.</p>
<p>The idea behind <code>josh</code> started with two questions:</p>
<ol>
<li>What if history filtering could be so fast that it can be part of a normal, everyday workflow,
running on every single push and fetch without the user even noticing?</li>
<li>What if history filtering was a non-destructive, reversible operation?</li>
</ol>
<p>Under those two premises a filter operation stops being a maintenance task. It seamlessly relates
histories between repos, which can be used by developers and CI systems interchangeably in whatever
way is most suitable to the task at hand.</p>
<p>How is this possible?</p>
<p>Filtering history is a highly predictable task: The set of filters that tend to be used for any
given repository is limited, such that the input to the filter (a git branch) only gets modified in
an incremental way. Thus, by keeping a persistent cache between filter runs, the work needed to
re-run a filter on a new commit (and its history) becomes proportional to the number of changes
since the last run; The work to filter no longer depends on the total length of the history.
Additionally, most filters also do not depend on the size of the trees.</p>
<p>What has long been known to be true for performing merges also applies to history filtering: The
more often it is done the less work it takes each time.</p>
<p>To guarantee filters are reversible we have to restrict the kind of filter that can be used; It is
not possible to write arbitrary filters using a scripting language like is allowed in other tools.
To still be able to cover a wide range of use cases we have introduced a domain-specific language to
express more complex filters as a combination of simpler ones. Apart from guaranteeing
reversibility, the use of a DSL also enables pre-optimization of filter expressions to minimize both
the amount of work to be done to execute the filter as well as the on-disk size of the persistent
cache.</p>
<blockquote>
<p><em><em>From Linus Torvalds 2007 talk at Google about git:</em></em></p>
<p><strong>Audience:</strong></p>
<p>Can you have just a part of files pulled out of a repository, not the entire repository?</p>
<p><strong>Linus:</strong></p>
<p>You can export things as tarballs, you can export things as individual files, you can rewrite the
whole history to say &quot;I want a new version of that repository that only contains that part&quot;, you
can do that, it is a fairly expensive operation it's something you would do for example when you
import an old repository into a one huge git repository and then you can split it later on to be
multiple smaller ones, you can do it, what I am trying to say is that you should generally try to
avoid it. It's not that git can not handle huge projects, git would not perform as well as it would
otherwise. And you will have issues that you wish you didn't not have.</p>
<p>So I am skipping this issue and going back to the performance issue. One of the things I want to
say about performance is that a lot of people seem to think that performance is about doing the
same thing, just doing it faster, and that is not true.</p>
<p>That is not what performance is all about. If you can do something really fast, really well, people
will start using it differently.</p>
</blockquote>
<h1 id="use-cases"><a class="header" href="#use-cases">Use cases</a></h1>
<h2 id="workspaces-in-a-mono-repo"><a class="header" href="#workspaces-in-a-mono-repo">Workspaces in a mono-repo</a></h2>
<p>Multiple projects, depending on a shared set of libraries, can live together in a single repository.
This approach is commonly referred to as “monorepo”, and was popularized by
<a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">Google</a>, Facebook or Twitter to name a
few.</p>
<p>In this example, two projects (<code>project1</code> and <code>project2</code>) coexist in the <code>central</code> monorepo.</p>
<table>
    <thead>
        <tr>
            <th>Central monorepo</th>
            <th>Project workspaces</th>
            <th>workspace.josh file</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td rowspan=2><img src="./img/central.svg?sanitize=true" alt="Folders and files in central.git" /></td>
            <td><img src="./img/project1.svg?sanitize=true" alt="Folders and files in project1.git" /></td>
            <td>
<pre>
dependencies = :/modules:[
    ::tools/
    ::library1/
]
</pre>
        </tr>
        <tr>
            <td><img src="./img/project2.svg?sanitize=true" alt="Folders and files in project2.git" /></td>
            <td>
<pre>libs/library1 = :/modules/library1</pre></td>
        </tr>
    </tbody>
</table>
<p>Each of the subprojects defines a <code>workspace.josh</code> file, defining the mapping between the original central.git repository and the hierarchy in use inside of the project.</p>
<p>In this setup, project1 and project2 can seemlessly depend on the latest version of library1, while only checking out the part of the central monorepo that's needed for their purpose.
What's more, any changes to a shared module will be synced in both directions.</p>
<p>If a developper of the library1 pushed a new update, both projects will get the new version, and the developper will be able to check if they broke any test.
If a developper of project1 needs to update the library, the changes will be automatically shared back into central, and project2.</p>
<h1 id="history-filtering"><a class="header" href="#history-filtering">History filtering</a></h1>
<p>Josh transforms commits by applying filters to them. As any
commit in git represents not just a single state of the filesystem but also its entire
history, applying a filter to a commit produces an entirely new history.
The result of a filter is a normal git commit and therefore can be filtered again,
making filters chainable.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Filters always begin with a colon and can be chained:</p>
<pre><code>:filter1:filter2
</code></pre>
<p>When used as part of an URL filters can not contain whitespace or newlines. When read from a file
however whitespace can be inserted between filters (not after the leading colon).
Additionally newlines can be used instead of <code>,</code> inside of composition filters.</p>
<h2 id="available-filters"><a class="header" href="#available-filters">Available filters</a></h2>
<h3 id="subdirectory-a"><a class="header" href="#subdirectory-a">Subdirectory <strong><code>:/a</code></strong></a></h3>
<p>Take only the selected subdirectory from the input and make it the root
of the filtered tree.
Note that <code>:/a/b</code> and <code>:/a:/b</code> are equivalent ways to get the same result.</p>
<h3 id="directory-a"><a class="header" href="#directory-a">Directory <strong><code>::a/</code></strong></a></h3>
<p>A shorthand for the commonly occuring filter combination <code>:/a:prefix=a</code>.</p>
<h3 id="file-a"><a class="header" href="#file-a">File <strong><code>::a</code></strong></a></h3>
<p>Produces a tree with only the specified file in it's root.
Note that <code>::a/b</code> is equivalent to <code>::a/::b</code>.</p>
<h3 id="prefix-prefixa"><a class="header" href="#prefix-prefixa">Prefix <strong><code>:prefix=a</code></strong></a></h3>
<p>Take the input tree and place it into subdirectory <code>a</code>.
Note that <code>:prefix=a/b</code> and <code>:prefix=b:prefix=a</code> are equivalent.</p>
<h3 id="composition-filter1filter2filtern"><a class="header" href="#composition-filter1filter2filtern">Composition <strong><code>:[:filter1,:filter2,...,:filterN]</code></strong></a></h3>
<p>Compose a tree by overlaying the outputs of <code>:filter1</code> ... <code>:filterN</code> on top of each other.
It is guaranteed that each file will only appear at most once in the output. The first filter
that consumes a file is the one deciding it's mapped location. Therefore the order in which
filters are composed matters.</p>
<p>Inside of a composition <code>x=:filter</code> can be used as an alternative spelling for
<code>:filter:prefix=x</code>.</p>
<h3 id="exclusion-excludefilter"><a class="header" href="#exclusion-excludefilter">Exclusion <strong><code>:exclude[:filter]</code></strong></a></h3>
<p>Remove all paths matching <code>:filter</code> from the input tree.</p>
<h3 id="workspace-workspacea"><a class="header" href="#workspace-workspacea">Workspace <strong><code>:workspace=a</code></strong></a></h3>
<p>Similar to <code>:/a</code> but also looks for a <code>workspace.josh</code> file inside the
specified directory (called the &quot;workspace root&quot;).
The resulting tree will contain the contents of the
workspace root as well as additional files specifed in the <code>workspace.josh</code> file.
(see <a href="./workspace.html">Workspaces</a>)</p>
<!--
## Pattern filters

The following filters accept a glob like pattern ``X`` that can contain ``*`` to
match any number of characters. Note that two or more consecutive wildcards (``**``) are not
allowed.

### Match directories **`::X/`**
All matching subdirectories in the input root

### Match files **`::X`**
All matching files in the input root

### Match nested directories **`::**/X/`**
All subdirectories matching the pattern in arbitarily deep subdirectories of the input

### Match nested files **`::**/X`**
All files matching the pattern in arbitarily deep subdirectories of the input
-->
<h2 id="filter-order-matters"><a class="header" href="#filter-order-matters">Filter order matters</a></h2>
<p>Filters are applied in the left-to-right order they are given in the filter specification,
and they are <code>not</code> commutative.</p>
<p>For example, this command will filter out just the josh documentation, and store it in a
ref named <code>FILTERED_HEAD</code>:</p>
<pre><code>$ josh-filter :/docs:prefix=josh-docs
</code></pre>
<p>However, <code>this</code> command will produce an empty branch:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/docs
</code></pre>
<p>What's happening in the latter command is that because the prefix filter is applied first, the
entire <code>josh</code> history already lives within the <code>josh-docs</code> directory, as it was just
transformed to exist there. Thus, to still get the docs, the command would need to be:</p>
<pre><code>$ josh-filter :prefix=josh-docs:/josh-docs/docs
</code></pre>
<p>which will contain the josh documentation at the base of the tree. We've lost the prefix, what
gives?? Because the original git tree was already transformed, and then the subdirectory filter
was applied to pull documentation from <code>josh-docs/docs</code>, the prefix is gone - it was filtered out
again by the subdirectory filter. Thus, the order in which filters are provided is crucial, as each
filter further transforms the latest transformation of the tree.</p>
<h1 id="josh-filter"><a class="header" href="#josh-filter">josh-filter</a></h1>
<p>Command to rewrite history using <code>josh</code> filter specs.
By default it will use <code>HEAD</code> as input and update <code>FILTERED_HEAD</code> with the filtered
history, taking a filter specification as argument.</p>
<h1 id="git-sync"><a class="header" href="#git-sync">git-sync</a></h1>
<p>A utility to make working with server side rewritten commits easier.
Those commits frequently get produced when making changes to <code>workspace.josh</code> files.</p>
<p>The command should be put into <code>PATH</code> and can be used as a drop-in replacement for <code>git push</code>.
It enables the server to <em>return</em> commits back to the client after a push. This is done by parsing
the messages sent back by the server for announcements of rewritten commits and then fetching
those to update the local references.
In case of a normal git server that does not rewrite anything, <code>git sync</code> will do exactly the
same as <code>git push</code>, also accepting the same arguments.</p>
<h1 id="josh-proxy"><a class="header" href="#josh-proxy">josh-proxy</a></h1>
<p>Josh provides an HTTP proxy server that can be used with any git hosting service which communicates
via HTTP.</p>
<p>It needs the URL of the upstream server and a local directory to store its data.
Optionally, a port to listen on can be specified. For example, running a local <code>josh-proxy</code>
instance for github.com on port 8000:</p>
<pre><code>$ docker run -p 8000:8000 -e JOSH_REMOTE=https://github.com -v josh-vol:/data/git esrlabs/josh-proxy:r21.03.08
</code></pre>
<p>For a first example of how to make use of josh, just the josh documentation can be checked out as
its own repository via this command:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs.git
</code></pre>
<blockquote>
<p><strong>Note</strong>: This URL needs to contain the <code>.git</code> suffix twice: once after the original path
and once more after the filter spec.</p>
</blockquote>
<p><code>josh-proxy</code> supports read and write access to the repository, so when making changes
to any files in the filtered repository, you can just commit and push them
like you are used to.</p>
<h2 id="url-syntax-and-breakdown"><a class="header" href="#url-syntax-and-breakdown">URL syntax and breakdown</a></h2>
<p>This is the URL of a <code>josh-proxy</code> instance:</p>
<pre><code>http://localhost:8000
</code></pre>
<p>This is the repository location on the upstream host on which to perform the filter operations:</p>
<pre><code>/esrlabs/josh.git
</code></pre>
<p>This is the set of filter operations to perform:</p>
<pre><code>:/docs.git
</code></pre>
<p>Much more information on the available filters and the syntax of all filters is covered in detail in
the <a href="./filters.html">filters</a> section.</p>
<h2 id="repository-naming"><a class="header" href="#repository-naming">Repository naming</a></h2>
<p>By default, a git URL is used to point to the remote repository to download <em>and also</em> to dictate
how the local repository shall be named.  It's important to learn that the last name in the URL is
what the local git client will name the new, local repository. For example:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs.git
</code></pre>
<p>will create the new repository at directory <code>docs</code>, as <code>docs.git</code> is the last name in the URL.</p>
<p>By default, this leads to rather odd-looking repositories when the <code>prefix</code> filter is the final
filter of a URL:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs:prefix=josh-docs.git
</code></pre>
<p>This will still clone just the josh documentation, but the final directory structure will look like
this:</p>
<pre><code>- prefix=josh-docs
  - josh-docs
    - &lt;docs&gt;
</code></pre>
<p>Having the root repository directory name be the fully-specified filter is most likely not what was
intended. This results from git's reuse and repurposing of the remote URL, as <code>prefix=josh-docs</code>
is the final name in the URL. With no other alternatives, this gets used for the repository name.</p>
<p>To explicitly specify a repository name, provide the desired name after the URL when cloning a new
repository:</p>
<pre><code>$ git clone http://localhost:8000/esrlabs/josh.git:/docs:prefix=josh-docs.git my-repo
</code></pre>
<h1 id="working-with-workspaces"><a class="header" href="#working-with-workspaces">Working with workspaces</a></h1>
<p>For the sake of this example we will assume a <code>josh-proxy</code> instance is running and serving a
repo on <code>http://josh/world.git</code> with some shared code in <code>shared</code>.</p>
<h2 id="create-a-new-workspace"><a class="header" href="#create-a-new-workspace">Create a new workspace</a></h2>
<p>To create a new workspace in the path <code>ws/hello</code> simply clone it as if it already exists:</p>
<pre><code>$ git clone http://josh/world.git:workspace=ws/hello.git
</code></pre>
<p><code>git</code> will report that you appear to have cloned an empty repository if that path does not
yet exist.
If you don't get this message it means that the path already exists in the repo but may
not yet have configured any path mappings.</p>
<p>The next step is to add some path mapping to the <code>workspace.josh</code> file in the root of the
workspace:</p>
<pre><code>$ cd hello
$ echo &quot;mod/a = :/shared/a&quot; &gt; workspace.josh
</code></pre>
<p>And and commit the changes:</p>
<pre><code>$ git add workspace.josh
$ git commit -m &quot;add workspace&quot;
</code></pre>
<p>If the path did not exist previously, the resulting commit will be a root commit that does not share
any history with the <code>world.git</code> repo.
This means a normal <code>git push</code> will be rejected at this point.
To get correct history, the
resulting commit needs to be a merge of our newly created workspace history with the history that
already exists in <code>world.git</code>.
There is however no way to do this merge locally, because we don't have the data required for this.
Also, the resulting tree should contain the contents of <code>shared/a</code> mapped to <code>mod/a</code> which
means it needs to be produced on the server side because we don't have the files to put there.</p>
<p>To accomplish that push with the merge option:</p>
<pre><code>$ git push -o merge origin master
</code></pre>
<blockquote>
<p><strong>Note</strong>: While it is perfectly possible to use Josh without a code review system,
it is strongly recommended to use some form of code review to be able to inspect commits
created by Josh before they get into the immutable history of your main repository.</p>
</blockquote>
<p>As the resulting commit is created on the server side we need to get it from the server:</p>
<pre><code>$ git pull --rebase
</code></pre>
<p>Now you should see <code>mod/a</code> populated with the content of the shared code.</p>
<h2 id="map-a-shared-path-into-a-workspace"><a class="header" href="#map-a-shared-path-into-a-workspace">Map a shared path into a workspace</a></h2>
<p>To add shared path to a location in the workspace that does not exist yet, first add an
entry to the <code>workspace.josh</code> file and commit that.</p>
<p>At this point the path is of course empty to the commit needs to be pushed to the server.
When the same commit is then fetched back it will have the mapped path populated with the
shared content.</p>
<h2 id="publish-a-non-shared-path-into-a-shared-location"><a class="header" href="#publish-a-non-shared-path-into-a-shared-location">Publish a non-shared path into a shared location</a></h2>
<p>The steps here are exactly the same as for the mapping example above. The only difference being
that the path already exists in the workspace but not in the shared location.</p>
<h2 id="remove-a-mapping"><a class="header" href="#remove-a-mapping">Remove a mapping</a></h2>
<p>To remove a mapping remove the corresponding entry from the <code>workspace.josh</code> file.
The content of the previously shared path will stay in the workspace. That means the main
repo will have two copies of that path from that point on. Effectivly creating a fork of that code.</p>
<h2 id="remove-a-mapped-path"><a class="header" href="#remove-a-mapped-path">Remove a mapped path</a></h2>
<p>To remove a mapped path as well as it's contents, remove the entry from the
<code>workspace.josh</code> file and also remove the path inside the workspace using <code>git rm</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
